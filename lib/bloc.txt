Development work flow

Understanding BLoC Pattern
BLoC = Business Logic Component

Events: User actions/triggers

States: UI states that change based on events

Bloc: Handles business logic and transforms events to states

When to Create Events, States, and Bloc Functions
Events (When to create):
User interactions (button taps, form submissions)

Lifecycle events (app started, page loaded)

External triggers (notifications, timers)

Data needs (fetch, update, delete)

States (When to create):
Different UI states (loading, success, error, initial)

Data changes that affect UI

Authentication states

Form validation states

Bloc Functions:
For each event, create a handler function

Business logic and API calls go here

State emissions based on logic results

Project Example: Todo App with API
Let's create a Todo app that communicates with a backend API.

Project Structure (Repository Design Pattern)

Layered Architecture
UI Layer (Widgets)
    ↓
BLoC Layer (State Management)
    ↓
Repository Layer (Data Abstraction)
    ↓
Service/Data Layer (API/DB)



lib/
├── blocs/
│   ├── todo_bloc.dart
│   ├── todo_event.dart
│   └── todo_state.dart
├── models/
│   └── todo_model.dart
├── repositories/
│   └── todo_repository.dart
├── services/
│   └── api_service.dart
└── pages/
    └── todo_page.dart
1. Model
dart
// models/todo_model.dart
class Todo {
  final int? id;
  final String title;
  final String description;
  final bool completed;

  Todo({
    this.id,
    required this.title,
    required this.description,
    this.completed = false,
  });

  factory Todo.fromJson(Map<String, dynamic> json) {
    return Todo(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      completed: json['completed'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'completed': completed,
    };
  }

  Todo copyWith({
    int? id,
    String? title,
    String? description,
    bool? completed,
  }) {
    return Todo(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      completed: completed ?? this.completed,
    );
  }
}
2. API Service
dart
// services/api_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/todo_model.dart';

class ApiService {
  static const String baseUrl = 'https://jsonplaceholder.typicode.com';

  final http.Client client;

  ApiService({required this.client});

  Future<List<Todo>> getTodos() async {
    final response = await client.get(Uri.parse('$baseUrl/todos'));
    if (response.statusCode == 200) {
      final List<dynamic> data = json.decode(response.body);
      return data.map((json) => Todo.fromJson(json)).toList();
    } else {
      throw Exception('Failed to load todos');
    }
  }

  Future<Todo> createTodo(Todo todo) async {
    final response = await client.post(
      Uri.parse('$baseUrl/todos'),
      body: json.encode(todo.toJson()),
      headers: {'Content-Type': 'application/json'},
    );
    if (response.statusCode == 201) {
      return Todo.fromJson(json.decode(response.body));
    } else {
      throw Exception('Failed to create todo');
    }
  }

  Future<Todo> updateTodo(Todo todo) async {
    final response = await client.put(
      Uri.parse('$baseUrl/todos/${todo.id}'),
      body: json.encode(todo.toJson()),
      headers: {'Content-Type': 'application/json'},
    );
    if (response.statusCode == 200) {
      return Todo.fromJson(json.decode(response.body));
    } else {
      throw Exception('Failed to update todo');
    }
  }

  Future<void> deleteTodo(int id) async {
    final response = await client.delete(
      Uri.parse('$baseUrl/todos/$id'),
    );
    if (response.statusCode != 200) {
      throw Exception('Failed to delete todo');
    }
  }
}
3. Repository
dart
// repositories/todo_repository.dart
import '../models/todo_model.dart';
import '../services/api_service.dart';

class TodoRepository {
  final ApiService apiService;

  TodoRepository({required this.apiService});

  Future<List<Todo>> getTodos() async {
    return await apiService.getTodos();
  }

  Future<Todo> createTodo(Todo todo) async {
    return await apiService.createTodo(todo);
  }

  Future<Todo> updateTodo(Todo todo) async {
    return await apiService.updateTodo(todo);
  }

  Future<void> deleteTodo(int id) async {
    return await apiService.deleteTodo(id);
  }
}
4. Events
dart
// blocs/todo_event.dart
part of 'todo_bloc.dart';

abstract class TodoEvent extends Equatable {
  const TodoEvent();

  @override
  List<Object> get props => [];
}

class LoadTodosEvent extends TodoEvent {}

class AddTodoEvent extends TodoEvent {
  final String title;
  final String description;

  const AddTodoEvent({required this.title, required this.description});

  @override
  List<Object> get props => [title, description];
}

class UpdateTodoEvent extends TodoEvent {
  final Todo todo;

  const UpdateTodoEvent({required this.todo});

  @override
  List<Object> get props => [todo];
}

class DeleteTodoEvent extends TodoEvent {
  final int id;

  const DeleteTodoEvent({required this.id});

  @override
  List<Object> get props => [id];
}

class ToggleTodoEvent extends TodoEvent {
  final Todo todo;

  const ToggleTodoEvent({required this.todo});

  @override
  List<Object> get props => [todo];
}
5. States
dart
// blocs/todo_state.dart
part of 'todo_bloc.dart';

abstract class TodoState extends Equatable {
  const TodoState();

  @override
  List<Object> get props => [];
}

class TodoInitialState extends TodoState {}

class TodoLoadingState extends TodoState {}

class TodoLoadedState extends TodoState {
  final List<Todo> todos;

  const TodoLoadedState({required this.todos});

  @override
  List<Object> get props => [todos];
}

class TodoErrorState extends TodoState {
  final String message;

  const TodoErrorState({required this.message});

  @override
  List<Object> get props => [message];
}

class TodoOperationSuccessState extends TodoState {
  final String message;

  const TodoOperationSuccessState({required this.message});

  @override
  List<Object> get props => [message];
}
6. BLoC
dart
// blocs/todo_bloc.dart
import 'dart:async';
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import '../models/todo_model.dart';
import '../repositories/todo_repository.dart';

part 'todo_event.dart';
part 'todo_state.dart';

class TodoBloc extends Bloc<TodoEvent, TodoState> {
  final TodoRepository todoRepository;

  TodoBloc({required this.todoRepository}) : super(TodoInitialState()) {
    on<LoadTodosEvent>(_onLoadTodos);
    on<AddTodoEvent>(_onAddTodo);
    on<UpdateTodoEvent>(_onUpdateTodo);
    on<DeleteTodoEvent>(_onDeleteTodo);
    on<ToggleTodoEvent>(_onToggleTodo);
  }

  FutureOr<void> _onLoadTodos(
      LoadTodosEvent event, Emitter<TodoState> emit) async {
    emit(TodoLoadingState());
    try {
      final todos = await todoRepository.getTodos();
      emit(TodoLoadedState(todos: todos));
    } catch (e) {
      emit(TodoErrorState(message: e.toString()));
    }
  }

  FutureOr<void> _onAddTodo(
      AddTodoEvent event, Emitter<TodoState> emit) async {
    try {
      final newTodo = Todo(
        title: event.title,
        description: event.description,
      );
      await todoRepository.createTodo(newTodo);

      // Reload todos after adding
      add(LoadTodosEvent());

      emit(TodoOperationSuccessState(message: 'Todo added successfully'));
    } catch (e) {
      emit(TodoErrorState(message: e.toString()));
    }
  }

  FutureOr<void> _onUpdateTodo(
      UpdateTodoEvent event, Emitter<TodoState> emit) async {
    try {
      await todoRepository.updateTodo(event.todo);
      add(LoadTodosEvent());
    } catch (e) {
      emit(TodoErrorState(message: e.toString()));
    }
  }

  FutureOr<void> _onDeleteTodo(
      DeleteTodoEvent event, Emitter<TodoState> emit) async {
    try {
      await todoRepository.deleteTodo(event.id);
      add(LoadTodosEvent());
    } catch (e) {
      emit(TodoErrorState(message: e.toString()));
    }
  }

  FutureOr<void> _onToggleTodo(
      ToggleTodoEvent event, Emitter<TodoState> emit) async {
    try {
      final updatedTodo = event.todo.copyWith(completed: !event.todo.completed);
      await todoRepository.updateTodo(updatedTodo);
      add(LoadTodosEvent());
    } catch (e) {
      emit(TodoErrorState(message: e.toString()));
    }
  }
}
7. UI Page
dart
// pages/todo_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../blocs/todo_bloc.dart';
import '../models/todo_model.dart';

class TodoPage extends StatelessWidget {
  const TodoPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo App with BLoC'),
        actions: [
          IconButton(
            icon: const Icon(I.refresh),
            onPressed: () {
              context.read<TodoBloc>().add(LoadTodosEvent());
            },
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddTodoDialog(context),
        child: const Icon(I.add),
      ),
      body: BlocConsumer<TodoBloc, TodoState>(
        listener: (context, state) {
          if (state is TodoErrorState) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(state.message)),
            );
          }
          if (state is TodoOperationSuccessState) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(state.message)),
            );
          }
        },
        builder: (context, state) {
          if (state is TodoLoadingState) {
            return const Center(child: CircularProgressIndicator());
          }

          if (state is TodoErrorState) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('Error: ${state.message}'),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      context.read<TodoBloc>().add(LoadTodosEvent());
                    },
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }

          if (state is TodoLoadedState) {
            final todos = state.todos;
            return ListView.builder(
              itemCount: todos.length,
              itemBuilder: (context, index) {
                final todo = todos[index];
                return TodoItem(
                  todo: todo,
                  onToggle: () {
                    context.read<TodoBloc>().add(ToggleTodoEvent(todo: todo));
                  },
                  onDelete: () {
                    context.read<TodoBloc>().add(DeleteTodoEvent(id: todo.id!));
                  },
                );
              },
            );
          }

          return const Center(child: Text('Press refresh to load todos'));
        },
      ),
    );
  }

  void _showAddTodoDialog(BuildContext context) {
    final titleController = TextEditingController();
    final descriptionController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add Todo'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: const InputDecoration(labelText: 'Title'),
            ),
            TextField(
              controller: descriptionController,
              decoration: const InputDecoration(labelText: 'Description'),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              if (titleController.text.isNotEmpty) {
                context.read<TodoBloc>().add(
                  AddTodoEvent(
                    title: titleController.text,
                    description: descriptionController.text,
                  ),
                );
                Navigator.pop(context);
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }
}

class TodoItem extends StatelessWidget {
  final Todo todo;
  final VoidCallback onToggle;
  final VoidCallback onDelete;

  const TodoItem({
    super.key,
    required this.todo,
    required this.onToggle,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: ListTile(
        leading: Checkbox(
          value: todo.completed,
          onChanged: (value) => onToggle(),
        ),
        title: Text(
          todo.title,
          style: TextStyle(
            decoration: todo.completed ? TextDecoration.lineThrough : null,
          ),
        ),
        subtitle: Text(todo.description),
        trailing: IconButton(
          icon: const Icon(I.delete, color: Colors.red),
          onPressed: onDelete,
        ),
      ),
    );
  }
}

8. Main App
dart
// main.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:http/http.dart' as http;
import 'blocs/todo_bloc.dart';
import 'pages/todo_page.dart';
import 'repositories/todo_repository.dart';
import 'services/api_service.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiRepositoryProvider(
      providers: [
        RepositoryProvider(
          create: (context) => ApiService(client: http.Client()),
        ),
        RepositoryProvider(
          create: (context) => TodoRepository(
            apiService: RepositoryProvider.of<ApiService>(context),
          ),
        ),
      ],
      child: MultiBlocProvider(
        providers: [
          BlocProvider(
            create: (context) => TodoBloc(
              todoRepository: RepositoryProvider.of<TodoRepository>(context),
            )..add(LoadTodosEvent()),
          ),
        ],
        child: MaterialApp(
          title: 'Todo App with BLoC',
          theme: ThemeData(
            primarySwatch: Colors.blue,
          ),
          home: const TodoPage(),
        ),
      ),
    );
  }
}

Dependencies (pubspec.yaml)
yaml
dependencies:
  flutter:
    sdk: flutter
  http: ^1.1.0
  bloc: ^8.1.0
  flutter_bloc: ^8.1.1
  equatable: ^2.0.5

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0
Key Implementation Points:
Events Created For:

Loading todos

Adding new todo

Updating todo

Deleting todo

Toggling completion status

States Created For:

Initial state

Loading state

Loaded data state

Error state

Operation success state

BLoC Functions:

Each event has a handler

API calls in repository

State emissions based on API results

Error handling

This example demonstrates a complete BLoC implementation with API communication, proper state management, and a clean architecture pattern.